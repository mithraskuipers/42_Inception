################################################################################
# Download VirtualBox
################################################################################

https://www.virtualbox.org/wiki/Downloads

################################################################################
# Install the virtual machine
################################################################################

Create Virtual Machine

Name: Ubuntu
ISO Image: ubuntu-22.04.2-desktop-amd64.iso
Check: Skip Unattended Installation
[Next]

Base Memory: 4096
Processors: 2
[Next]

Disk Size: 20 GB
[Next]

[Finish]

Now start the virtual machine.

[Install Ubuntu]

[Continue]

[Continue]

[Install Now]

[Continue]

[Continue]

Now enter your desired login credentials.

Check: Log in automatically
(I chose this for quick debugging and rebooting throughout the project)

[Continue]

It will now first copy over the installation files.
Then it will install the OS. Be patient.
While it is installing, you can already do the next network settings step.

################################################################################
# Install guest additionsdocker exec -it wordpress ps aux | grep 'php'
################################################################################

With the virtual machine booted, in the virtualbox taskbar:
Devices -> Insert Guest Additions CD image...
cd /media/$USER/VBox_GAs_7.0.6
sudo bash VBoxLinuxAdditions.run
sudo systemctl reboot

################################################################################
# Install ssh server
################################################################################

sudo apt-get instal openssh-server

################################################################################
Enable SSH
################################################################################

sudo nano /etc/ssh/sshd_config

Set "Port" to "42"
(This is because port 22 is already occupied by ssh of the host machine)

Set "PermitRootLogin" to "yes"

Set "PubkeyAuthentication" to "no"

sudo systemctl restart ssh
sudo systemctl restart ssh.service

sudo systemctl status ssh
sudo systemctl status ssh.service

(Confirm that it is indeed listening on port 42)

################################################################################
Configure firewall for ssh and for website
On the VM
################################################################################
sudo ufw enable
sudo ufw allow 42
sudo ufw allow 443
sudo ufw allow 80
sudo ufw status
sudo systemctl reboot

################################################################################
On the host
################################################################################

Name	Protocol	HostIP		HostPort	GuestIP		GuestPort
SSH	TCP							42					42
HTTP	TCP						80					80
HTTPS	TCP						443					443

################################################################################
SSH into the machine
On the host
################################################################################

ssh mikuiper@127.0.0.1 -p 42
ssh mikuiper@localhost -p 42

################################################################################
# Applications
################################################################################

sudo apt-get install nmap

# Optional
sudo apt-get install neofetch
sudo apt-get install snapd ; sudo snap install btop

################################################################################
# Connection method 1: Connect via SSH from terminal
################################################################################

export intraname=mikuiper

ssh-keygen -f "/home/$USER/.ssh/known_hosts" -R "[127.0.0.1]:42"
ssh mikuiper@127.0.0.1 -p 42

################################################################################
# Connection method 2: Connect via SSH via VSCODE
################################################################################

F1 > Remote-SSH: Connect to Host...
ssh mikuiper@127.0.0.1 -p 42

This will initialize the VS Code Server

################################################################################
# Install Docker
################################################################################

sudo apt-get update
sudo apt-get upgrade -y
sudo apt-get install make curl lsb-release ca-certificates apt-transport-https software-properties-common hostsed -y
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce -y
sudo apt-get update
sudo apt-get install docker-compose docker-compose-plugin -y
sudo apt-get update
sudo rm -rf /var/lib/apt/lists/*
sudo systemctl start docker
sudo systemctl reboot

################################################################################
# Test Docker service with hello-world
################################################################################

sudo systemctl status docker
sudo docker run hello-world

################################################################################
On the VM
################################################################################

sudo usermod -aG docker $USER
logout
Log back in
groups
(to check if you are added to the "docker" group)

################################################################################
Test your own webserver
################################################################################

https://github.com/mithraskuipers/docker_nginx_test.git ~/docker_nginx_test
cd ~/docker_nginx_test
sudo docker-compose up -d
Test the nginx webserver by opening up a browser and going to localhost or http://127.0.0.1

If you do not get to see a webpage with a positive message, something went wrong.
It means that you might not have opened the ports correctly, or that port 80 is busy with something on the host machine.

################################################################################
# Create folder structure conform the subject
# On VM
################################################################################

Browse to the location where you want the inception project to be stored.

# Set the temporary intraname env variable
export intraname=mikuiper

Then run:

# Create folders
mkdir -p /home/$USER/inception/srcs/requirements/mariadb/conf
mkdir -p /home/$USER/inception/srcs/requirements/mariadb/tools
mkdir -p /home/$USER/inception/srcs/requirements/nginx/conf
mkdir -p /home/$USER/inception/srcs/requirements/nginx/tools
mkdir -p /home/$USER/inception/srcs/requirements/wordpress/conf
mkdir -p /home/$USER/inception/srcs/requirements/wordpress/tools
mkdir -p /home/$USER/inception/srcs/requirements/tools
mkdir -p /home/$USER/inception/srcs/requirements/bonus

# Populate the folders
touch /home/$USER/inception/Makefile
touch /home/$USER/inception/srcs/.env
touch /home/$USER/inception/srcs/docker-compose.yml
touch /home/$USER/inception/srcs/requirements/mariadb/Dockerfile
touch /home/$USER/inception/srcs/requirements/mariadb/conf/create_db.sh
touch /home/$USER/inception/srcs/requirements/nginx/Dockerfile
touch /home/$USER/inception/srcs/requirements/nginx/conf/nginx.conf
touch /home/$USER/inception/srcs/requirements/wordpress/Dockerfile
touch /home/$USER/inception/srcs/requirements/wordpress/conf/wp-config-create.sh
touch /home/$USER/inception/srcs/requirements/mariadb/.dockerignore
touch /home/$USER/inception/srcs/requirements/wordpress/.dockerignore
touch /home/$USER/inception/srcs/requirements/mariadb/tools/.gitkeep
touch /home/$USER/inception/srcs/requirements/wordpress/tools/.gitkeep

# Populate the files
echo "DOMAIN_NAME=$intraname.42.fr" > /home/$USER/inception/srcs/.env
echo "CERT_=./requirements/tools/$intraname.42.fr.crt" >> /home/$USER/inception/srcs/.env
echo "KEY_=./requirements/tools/$intraname.42.fr.key" >> /home/$USER/inception/srcs/.env
echo "DB_NAME=wordpress" >> /home/$USER/inception/srcs/.env
echo "DB_ROOT=rootpass" >> /home/$USER/inception/srcs/.env
echo "DB_USER=wpuser" >> /home/$USER/inception/srcs/.env
echo "DB_PASS=wppass" >> /home/$USER/inception/srcs/.env
echo "" > /home/$USER/inception/srcs/requirements/mariadb/tools/.gitkeep
echo "" > /home/$USER/inception/srcs/requirements/wordpress/tools/.gitkeep
echo ".git" > /home/$USER/inception/srcs/requirements/wordpress/.dockerignore
echo ".git" > /home/$USER/inception/srcs/requirements/mariadb/.dockerignore
echo ".env" >> /home/$USER/inception/srcs/requirements/mariadb/.dockerignore
echo ".env" >> /home/$USER/inception/srcs/requirements/wordpress/.dockerignore

################################################################################
# 
################################################################################

# Change the local domain
echo "127.0.0.1 $USER.42.fr localhost" | sudo tee -a /etc/hosts
echo "127.0.0.1 $USER.42.fr:80" | sudo tee -a /etc/hosts

# Now test it out
http://mikuiper.42.fr

# Test your new domain
#Go to the cloned docker_nginx_test repository and run

sudo docker-compose down
sudo docker-compose up -d

# Install a self-signed ssl certificate
sudo apt update -y
sudo apt install -y wget curl libnss3-tools
cd
curl -s https://api.github.com/repos/FiloSottile/mkcert/releases/latest| grep browser_download_url  | grep linux-amd64 | cut -d '"' -f 4 | wget -qi -
mv mkcert-v*-linux-amd64 mkcert
chmod a+x mkcert
sudo mv mkcert /usr/local/bin/
mkcert --version

# Create key and certificate
cd /home/$USER/inception/srcs/requirements/tools/
mkcert "$USER.42.fr"

# Change file extension of the certificates to format that nginx can read
mv "$USER".42.fr-key.pem "$USER".42.fr.key
mv "$USER".42.fr.pem "$USER".42.fr.crt


################################################################################
# Change settings of the test nginx container for https (and test it)
################################################################################

sudo nano ~/docker_nginx_test/nginx/conf.d/nginx.conf

Replace its contents with the following code.
Change the intraname to yours.

server {
    # Listen on port http
    listen      80;
    # Listen on port https - ssl
    listen      443 ssl;
    # Set the domain we will be working on:
    server_name  mikuiper.42.fr www.mikuiper.42.fr;
    # Specify the root directory of the project:
    root    /var/www/public/html;
    # The next section is commented out for
    # normal operation with the host machine.
    # Redirect http to https:
    #if ($scheme = 'http') {
    #    return 301 https://mikuiper.42.fr$request_uri;
    #}
    # Specify the path to the certificate and key:
    ssl_certificate     /etc/nginx/ssl/mikuiper.42.fr.crt;
    ssl_certificate_key /etc/nginx/ssl/mikuiper.42.fr.key;
    # Specify the supported tls protocols:
    ssl_protocols            TLSv1.2 TLSv1.3;
    # Specify caching options and timeouts:
    ssl_session_timeout 10m;
    keepalive_timeout 70;
    # Tell the server which file extension
    # to look for in our root folder:
    location / {
        try_files $uri /index.html;
    }
}



# The code sets up an Nginx server to listen on both port 80 (http) and port 443 (https) with SSL. It sets the domain name and specifies the root directory of the project. It also specifies the path to the SSL certificate and key, and the supported TLS protocols, caching options, and timeouts. Finally, it tells the server which file extension to look for in the root folder.

cd ~/docker_nginx_test/

sudo docker-compose down

sudo nano docker-compose.yml

Replace all its contents with the following. The difference with before is
only the extra entry in the volumes section. We do this so that the container
has access to our keys.

version: '3'

services:
  nginx:
    image: nginx:stable-alpine
    volumes:
      - ./public:/var/www/public/
      - ./nginx/conf.d:/etc/nginx/conf.d/
      - /home/mikuiper/inception/srcs/requirements/tools:/etc/nginx/ssl/
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    container_name: docker_nginx_test

Save it.

################################################################################
# Launch it
################################################################################

docker-compose up -d

Test it.
Go to:
https://mikuiper.42.fr/
For Firefox users: The page should show you "Warning: Potential Security Risk Ahead"
Click on the on button "Advanced", followed by "Accept the Risk and Continue"

Now the browser trusts the certificate we created. Our site is now also loaded via ssl.
Yet, our connection is still not considered to be secure. But that is none of our problems!


#### 
Create inception makefile
#####

sudo nano ~/inception/Makefile

name = simple_nginx_html
all:
	@printf "Launch configuration ${name}...\n"
	@docker-compose -f ./docker-compose.yml up -d

build:
	@printf "Building configuration ${name}...\n"
	@docker-compose -f ./docker-compose.yml up -d --build

down:
	@printf "Stopping configuration ${name}...\n"
	@docker-compose -f ./docker-compose.yml down

re:	down
	@printf "Rebuild configuration ${name}...\n"
	@docker-compose -f ./docker-compose.yml up -d --build

clean: down
	@printf "Cleaning configuration ${name}...\n"
	@docker system prune -a

fclean:
	@printf "Total clean of all configurations docker\n"
	@docker stop $$(docker ps -qa)
	@docker system prune --all --force --volumes
	@docker network prune --force
	@docker volume prune --force

.PHONY	: all build down re clean fclean



Save it.



#### 
Deploy nginx
#####

sudo nano ~/inception/srcs/requirements/nginx/conf/nginx.conf


server {
    listen      443 ssl;
    server_name  mikuiper.42.fr www.mikuiper.42.fr;
    root    /var/www/;
    index index.php index.html;
    ssl_certificate     /etc/nginx/ssl/mikuiper.42.fr.crt;
    ssl_certificate_key /etc/nginx/ssl/mikuiper.42.fr.key;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_session_timeout 10m;
    keepalive_timeout 70;
    location / {
        try_files $uri /index.php?$args /index.html;
        add_header Last-Modified $date_gmt;
        add_header Cache-Control 'no-store, no-cache';
        if_modified_since off;
        expires off;
        etag off;
    }
#    location ~ \.php$ {
#        fastcgi_split_path_info ^(.+\.php)(/.+)$;
#        fastcgi_pass wordpress:9000;
#        fastcgi_index index.php;
#        include fastcgi_params;
#        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
#        fastcgi_param PATH_INFO $fastcgi_path_info;
#    }
}


Save it.
This different from our test conf in the sence that it works under php so that it allows reading not html, but wordpress php files. We won't need port 80 anymore, since according to the guide we can only use port 443. But at the first stage, we will comment out the sections responsible for php and write html support for a while (for testing): 
Port 9000 is just the port of our php-fpm, which is used to connect between php and nginx. And wordpress in this case is the name of our container with wordpress. But for now, let's try to at least just run something on nginx. 


cp ~/inception/srcs/requirements/tools/* ~/inception/srcs/requirements/nginx/tools/

sudo nano ~/inception/srcs/docker-compose.yml

version: '3'

services:
  nginx:
    build:
      context: .
      dockerfile: requirements/nginx/Dockerfile
    container_name: nginx
#    depends_on:
#      - wordpress
    ports:
      - "443:443"
    volumes:
      - ./requirements/nginx/conf/:/etc/nginx/http.d/
      - ./requirements/nginx/tools:/etc/nginx/ssl/
      - /home/mikuiper/docker_nginx_test/public/html:/var/www/
    restart: always

Save it.

Turn off the test nginx container.

cd ~/docker_nginx_test
docker-compose down

cd ~/inception/srcs
docker-compose up -d

Test it out.
Remember we used port 443, which only allows for HTTPS
https://127.0.0.1
https://mikuiper.42.fr





#######
# Deploy mariadb
##########

nano requirements/mariadb/Dockerfile

FROM alpine:3.16

ARG DB_NAME \
    DB_USER \
    DB_PASS

RUN apk update && apk add --no-cache mariadb mariadb-client

RUN mkdir /var/run/mysqld; \
    chmod 777 /var/run/mysqld; \
    { echo '[mysqld]'; \
      echo 'skip-host-cache'; \
      echo 'skip-name-resolve'; \
      echo 'bind-address=0.0.0.0'; \
    } | tee  /etc/my.cnf.d/docker.cnf; \
    sed -i "s|skip-networking|skip-networking=0|g" \
      /etc/my.cnf.d/mariadb-server.cnf

RUN mysql_install_db --user=mysql --datadir=/var/lib/mysql

EXPOSE 3306

COPY requirements/mariadb/conf/create_db.sh .
RUN sh create_db.sh && rm create_db.sh
USER mysql
CMD ["/usr/bin/mysqld", "--skip-log-error"]

Save it.





# Database user creation script

sudo nano ~/inception/srcs/requirements/mariadb/Dockerfile


#!bin/sh

# Check if mysql is running. If not, start it.
if [ ! -d "/var/lib/mysql/mysql" ]; then

        chown -R mysql:mysql /var/lib/mysql

        # init database
        mysql_install_db --basedir=/usr --datadir=/var/lib/mysql --user=mysql --rpm

        tfile=`mktemp`
        if [ ! -f "$tfile" ]; then
                return 1
        fi
fi

# Check if wordpress exists.
if [ ! -d "/var/lib/mysql/wordpress" ]; then

        cat << EOF > /tmp/create_db.sql
USE mysql;
FLUSH PRIVILEGES;
DELETE FROM     mysql.user WHERE User='';
DROP DATABASE test;
DELETE FROM mysql.db WHERE Db='test';
DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');
ALTER USER 'root'@'localhost' IDENTIFIED BY '${DB_ROOT}';
CREATE DATABASE ${DB_NAME} CHARACTER SET utf8 COLLATE utf8_general_ci;
CREATE USER '${DB_USER}'@'%' IDENTIFIED by '${DB_PASS}';
GRANT ALL PRIVILEGES ON wordpress.* TO '${DB_USER}'@'%';
FLUSH PRIVILEGES;
EOF
        # run init.sql
        /usr/bin/mysqld --user=mysql --bootstrap < /tmp/create_db.sql
        rm -f /tmp/create_db.sql
fi



Save it.



# TEST IT!

cd ~/inception/srcs
sudo docker-compose up -d

docker exec -it mariadb mysql -u root

show databases;


##########
# Deploy wordpress
#########


sudo nano ~/inception/srcs/requirements/wordpress/Dockerfile


FROM alpine:3.16
ARG PHP_VERSION=8 \
    DB_NAME \
    DB_USER \
    DB_PASS
RUN apk update && apk upgrade && apk add --no-cache \
    php${PHP_VERSION} \
    php${PHP_VERSION}-fpm \
    php${PHP_VERSION}-mysqli \
    php${PHP_VERSION}-json \
    php${PHP_VERSION}-curl \
    php${PHP_VERSION}-dom \
    php${PHP_VERSION}-exif \
    php${PHP_VERSION}-fileinfo \
    php${PHP_VERSION}-mbstring \
    php${PHP_VERSION}-openssl \
    php${PHP_VERSION}-xml \
    php${PHP_VERSION}-zip \
    php${PHP_VERSION}-redis \
    wget \
    unzip && \
    sed -i "s|listen = 127.0.0.1:9000|listen = 9000|g" \
      /etc/php8/php-fpm.d/www.conf && \
    sed -i "s|;listen.owner = nobody|listen.owner = nobody|g" \
      /etc/php8/php-fpm.d/www.conf && \
    sed -i "s|;listen.group = nobody|listen.group = nobody|g" \
      /etc/php8/php-fpm.d/www.conf && \
    rm -f /var/cache/apk/*
WORKDIR /var/www
RUN wget https://wordpress.org/latest.zip && \
    unzip latest.zip && \
    cp -rf wordpress/* . && \
    rm -rf wordpress latest.zip
COPY ./requirements/wordpress/conf/wp-config-create.sh .
RUN sh wp-config-create.sh && rm wp-config-create.sh && \
    chmod -R 0777 wp-content/
CMD ["/usr/sbin/php-fpm8", "-F"]

Save it.




sudo nano ~/inception/srcs/docker-compose.yml

version: '3'

services:
  nginx:
    build:
      context: .
      dockerfile: requirements/nginx/Dockerfile
    container_name: nginx
    depends_on:
      - wordpress
    ports:
      - "443:443"
    networks:
      - inception
    volumes:
      - ./requirements/nginx/conf/:/etc/nginx/http.d/
      - ./requirements/nginx/tools:/etc/nginx/ssl/
      - wp-volume:/var/www/
    restart: always

  mariadb:
    build:
      context: .
      dockerfile: requirements/mariadb/Dockerfile
      args:
        DB_NAME: ${DB_NAME}
        DB_USER: ${DB_USER}
        DB_PASS: ${DB_PASS}
        DB_ROOT: ${DB_ROOT}
    container_name: mariadb
    ports:
      - "3306:3306"
    networks:
      - inception
    restart: always

  wordpress:
    build:
      context: .
      dockerfile: requirements/wordpress/Dockerfile
      args:
        DB_NAME: ${DB_NAME}
        DB_USER: ${DB_USER}
        DB_PASS: ${DB_PASS}
    container_name: wordpress
    depends_on:
      - mariadb
    restart: always
    networks:
      - inception
    volumes:
      - wp-volume:/var/www/

volumes:
  wp-volume:
    driver_opts:
      o: bind
      type: none
      device: /home/mikuiper/data/wordpress

  db-volume:
    driver_opts:
      o: bind
      type: none
      device: /home/mikuiper/data/mariadb

networks:
    inception:
        driver: bridge

Save it.


sudo nano ~/inception/srcs/requirements/wordpress/tools/make_dir.sh

#!/bin/bash
if [ ! -d "/home/mikuiper/data" ]; then
        mkdir ~/data
        mkdir ~/data/mariadb
        mkdir ~/data/wordpress
fi

sudo chmod +x ~/inception/srcs/requirements/wordpress/tools/make_dir.sh

bash ~/inception/srcs/requirements/wordpress/tools/make_dir.sh

ls ~/data

sudo nano ~/inception/srcs/requirements/wordpress/conf/wp-config-create.sh

#!bin/sh
if [ ! -f "/var/www/wp-config.php" ]; then
cat << EOF > /var/www/wp-config.php
<?php
define( 'DB_NAME', '${DB_NAME}' );
define( 'DB_USER', '${DB_USER}' );
define( 'DB_PASSWORD', '${DB_PASS}' );
define( 'DB_HOST', 'mariadb' );
define( 'DB_CHARSET', 'utf8' );
define( 'DB_COLLATE', '' );
define('FS_METHOD','direct');
\$table_prefix = 'wp_';
define( 'WP_DEBUG', false );
if ( ! defined( 'ABSPATH' ) ) {
define( 'ABSPATH', __DIR__ . '/' );}
define( 'WP_REDIS_HOST', 'redis' );
define( 'WP_REDIS_PORT', 6379 );
define( 'WP_REDIS_TIMEOUT', 1 );
define( 'WP_REDIS_READ_TIMEOUT', 1 );
define( 'WP_REDIS_DATABASE', 0 );
require_once ABSPATH . 'wp-settings.php';
EOF
fi

Save it.

sudo nano ~/inception/srcs/requirements/nginx/conf/nginx.conf


server {
    listen      443 ssl;
    server_name  mikuiper.42.fr www.mikuiper.42.fr;
    root    /var/www/;
    index index.php;
    ssl_certificate     /etc/nginx/ssl/mikuiper.42.fr.crt;
    ssl_certificate_key /etc/nginx/ssl/mikuiper.42.fr.key;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_session_timeout 10m;
    keepalive_timeout 70;
    location / {
        try_files $uri /index.php?$args;
        add_header Last-Modified $date_gmt;
        add_header Cache-Control 'no-store, no-cache';
        if_modified_since off;
        expires off;
        etag off;
    }
    location ~ \.php$ {
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass wordpress:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}

Save it.


# TEST IT

cd ~/inception/srcs

sudo docker-compose down
sudo docker-compose up -d --build

sudo docker exec -it wordpress ps aux | grep 'php'

sudo docker exec -it wordpress php -v

sudo docker exec -it wordpress php -m


# SETTING UP WORDPRESS

https://127.0.0.1



















################################################################################
# Check if port is in-use
################################################################################

sudo nmap -p 42 localhost

################################################################################
# Docker commands
################################################################################

# Start Docker container in detached mode
sudo docker-compose up -d

# Stop all running containers
docker stop $(docker ps -aq)

# Remove all containers
docker rm $(docker ps -aq)

# Remove all images
docker rmi $(docker images -q)

# Remove all unused containers/networks/images/volumes
sudo docker system prune --all --volumes

# Kills all running containers and removes all containers
docker ps -aq | xargs docker rm -f
























################################################################################
# Copy over your local Inception folder to virtual machine via SCP
################################################################################

Open a terminal and browse to your Inception directory.
Make sure you are not connected via SSH to the virtual machine.
scp -P 42 -r ~/repos/42_Inception/ mikuiper@127.0.0.1:~

################################################################################
# Docker Compose yaml uitleg
################################################################################

Docker Compose allows you to define and run more than one container
(i.e. multi-container) in your Docker applications. You can save your Docker
Compose configuration settings in a docker-compose.yml file. It defines the
services, networks, and volumes required by your application.

################################################################################
# Prepare for running the Makefile
################################################################################

mkdir -p /home/$USER/docker_container_volumes/wordpress;
mkdir -p /home/$USER/docker_container_volumes/mariadb;

################################################################################
# Run makefile?
################################################################################


################################################################################
# Make Desktop usable
################################################################################

sudo apt-get install firefox

################################################################################
# Running Docker containers + ports
################################################################################

sudo docker ps -a

################################################################################
# Find out the virtual machine's ip address
################################################################################

Look for docker0
ip addr show docker0
